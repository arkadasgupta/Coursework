    /*********** APACHE QUEUE**************/
//    pqueue_t *frontier;
//    frontier = pqueue_init(graph->vertexCount, cmp_fCost, get_fCost, set_fCost, get_pos, set_pos);
//    //cout << "coming here" << endl;
//    Node src_node = {src_vertex, 0, 0};
//    //Node goal_node = {goal_vertex,0,-1};
//    float goalLat = graph->latitudes[goal_vertex - 1];
//    float goalLong = graph->longitudes[goal_vertex - 1];
//    pqueue_insert(frontier, &src_node);
//    Node* currentNode;
//    while (pqueue_peek(frontier) != NULL) {
//        currentNode = (Node*) pqueue_pop(frontier);
//        //cout<<"Vertex:"<<currentNode->nodeNum<<endl;
//        if (currentNode->nodeNum == goal_vertex) {
//            cout << "Solution found" << endl;
//            return;
//        } else {
//            if (!(*(visitedArray + currentNode->nodeNum - 1))) {
//                //                expand(&currentNode,graph,goalLat,goalLong,&frontier,
//                //                        &gCostArray,&hCostArray,&fCostArray);
//                int earliest_edge = graph->vertexArray[currentNode->nodeNum - 1];
//                int final_edge = graph->vertexArray[currentNode->nodeNum];
//                for (int i = earliest_edge; i < final_edge; i++) {
//                    int child = graph->edgeArray[i];
//                    if (child == currentNode->parent) {
//                        continue;
//                    }
//                    //childNode.gCost = currentNode.gCost+e.weight;
//                    //*(*(gCostArray) + child - 1) = *(*(gCostArray) + ((*(currentNode))->nodeNum - 1)) + graph->weightArray[i];
//                    *(gCostArray + child - 1) = *(gCostArray+currentNode->nodeNum-1)+ graph->weightArray[i];
//                    //cout<<"gcost:"<<*(gCostArray + child - 1);
//                    float latitude = graph->latitudes[child - 1];
//                    float longitude = graph->longitudes[child - 1];
//                    //childNode.hCost=Graph.approxDist(latitude, longitude, goalNode.latitude, goalNode.longitude);
//                    *(hCostArray + child - 1) = computeHeuristic(latitude, longitude, goalLat, goalLong);
//                    //cout<<"hcost:"<<*(hCostArray + child - 1);
//                    //childNode.fCost=childNode.gCost+childNode.hCost;
//                    *(fCostArray + child - 1) = *(gCostArray + child - 1) + *(hCostArray + child - 1);
//                    //cout<<"fcost:"<<*(fCostArray + child - 1);
//                    //childNode.parent=currentNode;
//                    Node childNode = {child, (*(fCostArray + child - 1)), currentNode->nodeNum};
//                    //cout << "childNode info:" << childNode.nodeNum << ":" << childNode.fCost << ":" << childNode.parent << endl;
//                    pqueue_insert(frontier, (void*) (&childNode));
//                    Node* test = (Node*)pqueue_peek(frontier);
//                    cout<<"after insert"<<test->nodeNum<<"--"<<test->fCost<<endl;
//                
//                }
//                *(visitedArray + currentNode->nodeNum - 1) = true;
//            } else {
//                continue;
//            }
//        }
//    }
    /*********** APACHE QUEUE**************/

//static int
//cmp_fCost(double next, double curr)
//{
//	return (next > curr);
//}

//
//static double
//get_fCost(void *a)
//{
//	return (double) ((Node*) a)->fCost;
//}
//
//
//static void
//set_fCost(void *a, double fCost)
//{
//	((Node*) a)->fCost = fCost;
//}
//
//
//static size_t
//get_pos(void *a)
//{
//	return ((Node*) a)->pos;
//}
//
//
//static void
//set_pos(void *a, size_t pos)
//{
//	((Node *) a)->pos = pos;
//}


 

 
//int main(int argc, char **argv) {
//    int n; 
//    int i;
//    PQ q;
//    heapNode hn;
//    n = atoi(argv[1]);
//    initQueue(&q, n);
//    srand(time(NULL));
//    for (i = 0; i < n; ++i) {
//        hn.value = rand()%10000;
//        printf("enqueue node with value: %d\n", hn.value);
//        enqueue(hn, &q);
//    }
//    printf("\ndequeue all values:\n");
//    for (i = 0; i < n; ++i) {
//        hn = dequeue(&q);
//        printf("dequeued node with value: %d, queue size after removal: %d\n", hn.value, q.size);
//    }
//}
